# HTTP协议基础及发展历史

## 五层网络模型

物理层主要作用是定义物理设备如何传输数据，机器的硬件，网卡端口，网线等。

数据链路层在通信的实体间建立数据链路连接，比如最基础的数据传输数据流，可以自己选择二进制或者ASCII码形式等。

网络层为数据在结点之间创建逻辑链路，比如输入百度，网络层会为我们找到百度的网址，如何寻找到的过程就是网络层要做的事。

传输层：向用户提供可靠的端到端(End-to-End)服务。

应用层：为应用软件提供了很多服务，帮我们实现了HTTP协议，我们只要按照规则去使用HTTP协议；它构建于TCP协议之上；屏蔽了网络传输相关细节。

![五层模型](~@image/fiveLevelModel.png)

## HTTP协议的发展历史

### HTTP/0.9

最早的HTTP版本是0.9，它只有一个命令GET，没有HEADER等描述数据的信息，服务器发送完毕后，就关闭了TCP连接。

### HTTP/1.0

HTTP1.0增加了很多命令，比如POST, PUT, HEADER等，增加了status code 和 header，增加就多字符集的支持、多部分发送、权限、缓存等。

### HTTP/1.1

1. 在1.0的基础上增加了持久连接，原来一个HTTP请求就需要开启一个TCP连接，当请求完成后TCP连接就关闭了。创建TCP连接消耗是比较高的，延迟也会比较高，所以能够在建立完HTTP请求后不关闭TCP连接，后面新的HTTP请求依然使用该TCP连接的话，性能肯定会比较高。

2. 增加了pipeline。虽然我们的客户端能够在同一个TCP连接里面发送多个HTTP请求，但是在服务端我们对于进来的请求都是要按照顺序的进行返回。如果前一个请求的等待时间比较久
，而后一个请求处理比较快的话，后一个请求也不能先发送给客户端，先要等第一个请求数据发送完毕后才能发送，这里就有一个串行和并行的关系，这个问题在HTTP2里面进行了优化。

3. 增加了host和其他一些命令

### HTTP2

1. 在HTTP2里面所有的数据都是以二进制（最小数据单位是帧）传输，在HTTP1.1里面大部分是通过字符串传输的，所以数据的分片方式是不一样的。

2. 同一个连接里面发送多个请求不再需要按照顺序来

::: tip
原有请求是需要按照顺序来的，服务器端可以返回第一个请求的同时返回第二个请求
:::

3. 头信息压缩以及推送等提高效率的功能

::: tip
原有的请求中的头信息是全部发送的，比较消耗性能，头信息压缩后可以有效的减少带宽使用。原有的服务端都是被动的，在HTTP2中服务端可以作为主动方进行推送。
:::

## HTTP的三次握手

HTTP并没有连接这种状态的，HTTP只有请求和响应两种状态，而HTTP的请求是基于TCP连接，在HTTTP/1.0里面，HTTP在发起一个请求后会创建一个TCP连接，当服务器返回客户端并响应后就会关闭这个TCP连接，在HTTP/1.1中可以设置某种状态能够保证TCP连接不关闭，这样就减少了TCP连接的次数，减少内存消耗。在HTTP2里面HTTP请求和TCP连接是可以并发的，同一个用户对同一个服务器发起请求的话，就只需要一个TCP连接。

![三次握手时序图](~@image/three-way-handshake.png)

1. 客户端发起一个创建连接的数据包的请求，发送到服务端，其中包含标志位`SYN=1`(用来描述这是一个创建请求数据包)，还会发送一个数字`Seq`

2. 服务端接受到了数据包之后就会知道有一个客户端要跟我创建一个连接了，然后服务器就会开启一个TCP socket的端口，端口开启之后，就会返回给客户端，里面会包含`SYN`,`ACK=X+1`(客户端发来的`Seq`+1)，再发送一个Seq（服务器端创建的）。

3. 客户端接收到后，就证明服务器端已经允许进行连接了，然后再发送给服务端`ACK=Y+1`,再加上一个新的`Seq`

::: tip
为什么要进行TCP三次握手呢？
::: details 点击查看结果
是为了防止服务端开启一些无用的TCP连接，我们知道网络传输是有延迟的，当一个客户端发起一个请求连接的请求，服务端就直接创建了TCP连接，然后服务端返回给客户端的时候，数据包丢失了，然后客户端就一直没有接收到服务端返回的数据包，然后客户端认为一定时间没有接收到后就认为这个连接是关闭的，然后再发起一个新的请求，服务端并不知道客户端的状态，就会一直开着之前的TCP端口，等着客户端的请求，服务端的开销就浪费了。所以需要三次握手来确认状态，然服务端能够及时的察觉到一些问题，来关闭TCP连接端口。
:::

## URI、URL和URN

URI：Uniform Resourse Identifier/统一资源标识符，用来唯一标识互联网上的信息资源，包含URL和URN。

URL：Uniform Resourse Locator/统一资源定位器。

http://user:pass@host.com:80/path?query=string#hash

* `http://`: 这一部分叫做Schema，定义以怎样的一种方式或协议去访问资源，例如 http, ftp..., 不同的方式去访问，服务会不一样，解析方式也会不同。不同的协议，如何去发送数据，传输数据，解析数据也会不同。

* `user:pass@`: 代表访问某个资源之后，这个资源需要特定的身份才能去访问，就可以在前面加上指定用户。目前web开发中基本用不到

* `host.com`: 定位资源在互联网的位置

* `:80`：端口，服务器有非常非常多的端口，需要指定端口来寻找资源

* `/path`：路由，进行具体资源定位

* `?query=string`: 搜索参数

* `#hash`：代表文档的某一个片段，现在前端作为锚点的一个定位

URN: 永久统一资源定位符，在资源移动之后还能被找到，目前还没有非常成熟的使用方案。

## HTTP报文格式

![HTTP报文格式](~@image/HTTPMessageFormat.png)

::: tip 请求报文
首行包含了 HTTP方法、请求路径和HTTP 版本，通过空格隔开。然后是header部分
:::

::: tip 响应报文
首行包含了 HTTP 版本、状态码和状态，然后首部是header部分，首部和主体是通过一个空行隔开。
:::

### HTTP方法

用来定义对于资源的操作，最常用的有GET, POST, PUT, DELETE, 从定义上有各自的语义的，好的HTTP服务可以通过CODE判断结果。

### HTTP CODE

定义服务器对请求的处理结果，各个区间的CODE有各自的语义。

* `100-199`：代表操作要持续进行，需要做一些其他的操作，请求才能继续返回。

* `200-299`: 代表操作成功

* `300-399`: 代表操作需要重定向，通过别的方式取获取数据

* `400-499`: 代表请求有问题

* `500-599`： 代表服务器错误